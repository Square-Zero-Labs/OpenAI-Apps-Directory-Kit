# OpenAI Apps Directory Kit

The OpenAI Apps Directory Kit makes it easy to build an OpenAI App that serves as a specialized directory (for pizza places or dog parks or anything). It bundles React widgets (map, list, carousel, albums) and an MCP server that embeds those widgets directly in tool responses—no separate asset hosting required.

## What’s inside

- `src/` – React widgets and shared utilities for rendering directory data.
- `assets/` – Production bundles generated by the build step (inlined by the MCP server).
- `directory_server_node/` – Node MCP server implemented with the official TypeScript SDK.
- `build-all.mts` – Build orchestrator that emits hashed JS/CSS/HTML for each widget.

## Prerequisites

- Node.js 18+
- pnpm (or npm/yarn)

## Install

```bash
pnpm install
```

## Build the widgets

```bash
pnpm run build
```

This runs `build-all.mts`, producing versioned bundles for each widget in `assets/`. The bundles are self-contained so the server can inline the CSS/JS into every response.

For hot reload during widget development:

```bash
pnpm run dev
```

> Vite serves the widgets on `http://localhost:4044`. You can run it alongside the MCP server by starting each command in its own terminal.

To serve the current production bundles without Vite:

```bash
pnpm run build
pnpm run serve   # serves ./assets on http://localhost:4044
```

## Run the MCP server

```bash
pnpm run build        # ensure assets exist
cd directory_server_node
pnpm start
```

The server listens on `PORT` (default `8000`) and exposes four tools: `directory-map`, `directory-list`, `directory-carousel`, and `directory-albums`. Each tool response includes plain text, structured JSON data, and `_meta.openai/outputTemplate` metadata that binds the response to the inlined widget markup.

Supported tool arguments:

- `resultsTitle` _(optional)_ – heading to display above the returned directory results.
- `location` _(optional)_ – string matched against city and neighborhood fields.
- `price` _(optional)_ – single price tier (e.g., `$`) or list of tiers.
- `minRating` _(optional)_ – filter out places below this rating (0–5).
- `limit` _(optional)_ – maximum number of items to return (1–100).
- `location` _(optional)_ – matches city or neighborhood fields.

### Configuration

- Edit `directory_server_node/config/directory.json` to change copy, theming, field mappings, and optional Supabase settings. The dev and build scripts run `pnpm run sync:directory` automatically, and Vite watches the file, so the frontend widgets pick up your changes without touching multiple files.
- `branding.logoUrl` lets you add your own logo; the widgets automatically display it in their headers.
- `directory_server_node/data/directory-places.json` remains the bundled fallback dataset that seeds both the MCP server and the frontend preview defaults.
- To use Supabase, set `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` in your environment before starting the server. If either value is missing, the server automatically falls back to the bundled JSON data.

The MCP server now watches both JSON files and reloads them on the fly, so you can tweak copy or data without restarting the process. If you update the files while `pnpm dev` is running, the generated `src/directory-defaults.ts` refreshes automatically; otherwise run `pnpm run sync:directory` to regenerate the frontend defaults. Inside ChatGPT the widgets first show a playful loading illustration and only render places once fresh data arrives, so users never see stale results.

When you run `pnpm dev`, the local Vite server injects the latest structured content into `window.oai`, so the previews on `http://localhost:4044/<widget>.html` stay fully populated while you iterate; the hot-loading behavior remains unchanged when served through the MCP server.

## Testing in ChatGPT developer mode

1. Enable developer mode and add a custom connector in ChatGPT.
2. Point the connector at your MCP server (for example, `https://<your-ngrok-subdomain>.ngrok-free.app/mcp`).
3. Invoke one of the directory tools; ChatGPT will render the widgets using the embedded assets and structured content.
